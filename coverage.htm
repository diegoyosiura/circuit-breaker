
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">circuit-breaker/cmd/main.go (0.0%)</option>
				
				<option value="file1">circuit-breaker/internal/fakeserver.go (92.1%)</option>
				
				<option value="file2">circuit-breaker/pkg/circuitbreaker.go (76.2%)</option>
				
				<option value="file3">circuit-breaker/pkg/manger.go (92.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "circuit-breaker/internal"
        circuitbreaker "circuit-breaker/pkg"
        "fmt"
        "net/http"
        "sync"
        "time"
)

// main runs a benchmark-style test against a local fake HTTP server.
// It demonstrates how to:
// - Start and interact with a simulated API server (FakeServer)
// - Use the CircuitBreaker with concurrency and rate control
// - Spawn multiple parallel HTTP requests (using goroutines)
// - Measure and display total execution time and request results
func main() <span class="cov0" title="0">{
        // Start a local fake server on localhost:8080
        // The FakeServer simulates processing delays and tracks statistics
        fs := internal.NewFakeServer("localhost", 8080)
        go fs.Listen()

        // Allow server time to fully start before sending traffic
        time.Sleep(5 * time.Second)

        // Initialize the CircuitBreaker manager
        m := circuitbreaker.NewManager()

        // Create or retrieve a named CircuitBreaker:
        // name: "google"
        // maxConcurrent: 50 → up to 50 parallel requests
        // maxRequests: 200 → up to 200 requests every 30 seconds (rate limit)
        // windowSeconds: 30
        // maxRetries: 5 → retry failed requests up to 5 times
        cb := m.NewCircuitBreaker("google", 50, 200, 30, 5)

        var wg sync.WaitGroup
        total := 3000 // Total number of requests to simulate

        start := time.Now() // Start measuring total time

        // Spawn 3000 concurrent requests to the /teste endpoint
        for i := 0; i &lt; total; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(i int) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Create a new HTTP GET request to the test endpoint
                        req, _ := http.NewRequest("GET", "http://localhost:8080/teste", nil)

                        // Execute the request through the CircuitBreaker
                        resp, err := cb.Do(req)

                        // Print result or error
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[Req %04d] ERROR: %v\n", i, err)
                                return
                        }</span>
                        <span class="cov0" title="0">defer resp.Body.Close()
                        fmt.Printf("[Req %04d] OK: %s\n", i, resp.Status)</span>
                }(i)
        }

        // Wait for all goroutines to complete
        <span class="cov0" title="0">wg.Wait()

        // Display the total elapsed time for all requests
        fmt.Println("Total time:", time.Since(start))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package internal

import (
        "fmt"
        "math/rand"
        "net/http"
        "sync"
        "time"
)

// FakeServer simulates an HTTP server used to test request throughput,
// concurrency limits, and delay handling in a realistic environment.
// It tracks metrics such as:
// - Current simultaneous connections
// - Maximum simultaneous connections
// - Requests per second (RPS)
// - Maximum RPS
// - Average RPS over time
type FakeServer struct {
        mu                   *sync.Mutex    // Ensures thread-safe access to metrics
        mux                  *http.ServeMux // HTTP multiplexer for routing requests
        currentConnections   int            // Number of requests currently being handled
        maxSimultaneous      int            // Peak of simultaneous connections
        requestsPerSecond    int            // Number of requests received in the current second
        maxRequestsPerSecond int            // Highest RPS recorded
        totalRequests        int            // Cumulative request count since start
        startTime            time.Time      // Time the server was initialized
        server               *http.Server   // Underlying HTTP server instance
}

// NewFakeServer initializes a new instance of FakeServer.
// It sets up a basic HTTP server listening on the given address and port,
// and starts background goroutines to track statistics.
func NewFakeServer(server string, port int) *FakeServer <span class="cov1" title="1">{
        mux := http.NewServeMux()

        fs := &amp;FakeServer{
                mu:                   &amp;sync.Mutex{},
                mux:                  mux,
                currentConnections:   0,
                maxSimultaneous:      0,
                requestsPerSecond:    0,
                maxRequestsPerSecond: 0,
                totalRequests:        0,
                startTime:            time.Now(),
                server: &amp;http.Server{
                        Addr:    fmt.Sprintf("%s:%d", server, port),
                        Handler: mux,
                },
        }

        // Register the handler for the /teste endpoint
        mux.HandleFunc("/teste", fs.handle)

        // Launch background goroutines to monitor metrics
        go fs.reset() // Updates maxRPS every second
        go fs.stats() // Prints stats every 5 seconds

        return fs
}</span>

// handle is the HTTP handler for /teste.
// It simulates a processing delay between 1-5 seconds,
// and updates connection counters and request metrics.
func (f *FakeServer) handle(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        // Lock before updating shared state
        f.mu.Lock()
        f.currentConnections++
        f.requestsPerSecond++
        f.totalRequests++

        // Track peak of simultaneous connections
        if f.currentConnections &gt; f.maxSimultaneous </span><span class="cov1" title="1">{
                f.maxSimultaneous = f.currentConnections
        }</span>
        <span class="cov1" title="1">f.mu.Unlock()

        // Ensure connection count is decremented when finished
        defer func() </span><span class="cov1" title="1">{
                f.mu.Lock()
                f.currentConnections--
                f.mu.Unlock()
        }</span>()

        // Simulate variable processing time (1–5 seconds)
        <span class="cov1" title="1">delay := time.Duration(rand.Intn(5)+1) * time.Second
        time.Sleep(delay)

        // Respond to the client
        fmt.Fprintf(w, "Resposta OK (delay %v)\n", delay)</span>
}

// reset is a background goroutine that runs every second.
// It checks whether the current RPS exceeds the maximum recorded,
// and resets the per-second request counter.
func (f *FakeServer) reset() <span class="cov1" title="1">{
        for </span><span class="cov10" title="4">{
                time.Sleep(1 * time.Second)
                f.mu.Lock()

                // Update max RPS if current second exceeds previous max
                if f.requestsPerSecond &gt; f.maxRequestsPerSecond </span><span class="cov1" title="1">{
                        f.maxRequestsPerSecond = f.requestsPerSecond
                }</span>

                // Reset current second counter
                <span class="cov8" title="3">f.requestsPerSecond = 0
                f.mu.Unlock()</span>
        }
}

// stats is a background goroutine that runs every 5 seconds.
// It prints a snapshot of:
// - Maximum simultaneous connections observed
// - Maximum requests per second recorded
// - Average requests per second since server start
func (f *FakeServer) stats() <span class="cov1" title="1">{
        for </span><span class="cov1" title="1">{
                time.Sleep(5 * time.Second)
                f.mu.Lock()

                // Calculate average RPS since startup
                elapsed := time.Since(f.startTime).Seconds()
                var avg float64
                if elapsed &gt; 0 </span><span class="cov0" title="0">{
                        avg = float64(f.totalRequests) / elapsed
                }</span>

                // Print collected statistics
                <span class="cov0" title="0">fmt.Printf("📊 Máx. simultâneas: %d | Máx. req/s: %d | Média req/s: %.2f\n",
                        f.maxSimultaneous, f.maxRequestsPerSecond, avg)

                f.mu.Unlock()</span>
        }
}

// Listen starts the HTTP server and blocks until it stops.
// This should be called after NewFakeServer() to begin accepting requests.
func (f *FakeServer) Listen() <span class="cov1" title="1">{
        fmt.Println("Servidor falso ouvindo em http://localhost:8080")
        _ = f.server.ListenAndServe() // Starts the HTTP server (errors are ignored here)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package circuitbreaker

import (
        "context"
        "errors"
        "net"
        "net/http"
        "os"
        "sync"
        "syscall"
        "time"
)

// CircuitBreaker implements a resilient HTTP request handler with the following features:
// - Maximum number of concurrent requests
// - Rate-limiting using a token bucket algorithm
// - Automatic retries for transient network failures
// - Context-aware cancellation and timeout support
type CircuitBreaker struct {
        Name          string        // Circuit identifier
        MaxConcurrent int           // Maximum concurrent requests allowed
        Client        *http.Client  // Underlying HTTP client used to execute requests
        MaxRetries    int           // Number of retry attempts allowed for retryable failures
        sem           chan struct{} // Semaphore to control concurrent request slots
        tokens        chan struct{} // Token bucket channel to regulate request rate
        tokenInterval time.Duration // Interval between tokens being added to the bucket
        tokenStop     chan struct{} // Channel to signal shutdown of the token generator

        tokenWaitGroup sync.WaitGroup // WaitGroup to ensure graceful token goroutine shutdown
        stopOnce       sync.Once      // Ensures Stop() only closes the channel once
}

// NewCircuitBreaker initializes a new CircuitBreaker instance with concurrency, rate, and retry controls.
// - name: Identifier for this circuit
// - maxConcurrent: Max number of simultaneous requests
// - maxRequests: Max number of requests per time window
// - windowSeconds: Duration of the rate-limiting window
// - maxRetries: Max number of retry attempts on failure
func NewCircuitBreaker(name string, maxConcurrent, maxRequests int, windowSeconds int, maxRetries int) *CircuitBreaker <span class="cov3" title="4">{
        cb := &amp;CircuitBreaker{
                Name:          name,
                MaxConcurrent: maxConcurrent,
                MaxRetries:    maxRetries,
                Client:        &amp;http.Client{Timeout: 10 * time.Second}, // Default timeout
        }

        if maxConcurrent &gt; 0 </span><span class="cov3" title="4">{
                cb.sem = make(chan struct{}, maxConcurrent)
        }</span>

        <span class="cov3" title="4">if maxRequests &gt; 0 &amp;&amp; windowSeconds &gt; 0 </span><span class="cov3" title="4">{
                cb.tokens = make(chan struct{}, maxRequests)
                interval := (time.Duration(windowSeconds) * time.Second) / time.Duration(maxRequests)
                if interval &lt;= 0 </span><span class="cov0" title="0">{
                        interval = time.Nanosecond
                }</span>
                <span class="cov3" title="4">cb.tokenInterval = interval
                cb.tokenStop = make(chan struct{})

                for i := 0; i &lt; cap(cb.tokens); i++ </span><span class="cov10" title="65">{
                        cb.tokens &lt;- struct{}{}
                }</span>

                <span class="cov3" title="4">cb.startTokenBucket()</span>
        }

        <span class="cov3" title="4">return cb</span>
}

// startTokenBucket starts a background goroutine that generates tokens at regular intervals
// to enforce the request rate limit using a token bucket mechanism.
func (cb *CircuitBreaker) startTokenBucket() <span class="cov3" title="4">{
        if cb.tokens == nil || cb.tokenStop == nil || cb.tokenInterval &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="4">cb.tokenWaitGroup.Add(1)
        go func() </span><span class="cov3" title="4">{
                defer cb.tokenWaitGroup.Done()
                ticker := time.NewTicker(cb.tokenInterval)
                defer ticker.Stop()

                for </span><span class="cov6" title="14">{
                        select </span>{
                        case &lt;-cb.tokenStop:<span class="cov3" title="3">
                                return</span> // Stop signal received
                        case &lt;-ticker.C:<span class="cov5" title="10">
                                select </span>{
                                case cb.tokens &lt;- struct{}{}:<span class="cov3" title="3"></span>
                                default:<span class="cov5" title="7"></span>
                                        // Token bucket is full; drop the token (non-blocking)
                                }
                        }
                }
        }()
}

// Do executes the HTTP request, ensuring that:
// - Concurrency and rate limits are respected
// - Retry logic is applied on retryable errors
// - Context cancellation or timeout is observed
func (cb *CircuitBreaker) Do(req *http.Request) (*http.Response, error) <span class="cov3" title="4">{
        if cb.sem != nil </span><span class="cov3" title="4">{
                // Wait for a concurrency slot or return if context is cancelled
                select </span>{
                case cb.sem &lt;- struct{}{}:<span class="cov3" title="4"></span>
                case &lt;-req.Context().Done():<span class="cov0" title="0">
                        return nil, req.Context().Err()</span>
                }
                <span class="cov3" title="4">defer func() </span><span class="cov3" title="4">{ &lt;-cb.sem }</span>() // Release concurrency slot
        }

        <span class="cov3" title="4">for attempt := 0; attempt &lt;= cb.MaxRetries; attempt++ </span><span class="cov4" title="6">{
                if err := cb.waitForToken(req.Context()); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                // Clone the request to avoid reuse issues with Body on retries
                <span class="cov4" title="5">newReq := req.Clone(req.Context())

                // Attempt the request
                resp, err := cb.Client.Do(newReq)
                if err == nil </span><span class="cov3" title="3">{
                        return resp, nil // Success
                }</span>

                // Return immediately if the error is not retryable
                <span class="cov2" title="2">if !isRetryable(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // If retries remain, back off slightly before trying again
                <span class="cov2" title="2">if attempt &lt; cb.MaxRetries </span><span class="cov2" title="2">{
                        time.Sleep(500 * time.Millisecond)
                }</span>
        }

        // All retry attempts failed
        <span class="cov0" title="0">return nil, errors.New("request failed after retries")</span>
}

// Stop gracefully shuts down the token bucket goroutine.
// Should be called when the circuit is no longer needed.
func (cb *CircuitBreaker) Stop() <span class="cov3" title="3">{
        if cb.tokenStop == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">cb.stopOnce.Do(func() </span><span class="cov3" title="3">{
                close(cb.tokenStop)
        }</span>)
        <span class="cov3" title="3">cb.tokenWaitGroup.Wait()</span>
}

func (cb *CircuitBreaker) waitForToken(ctx context.Context) error <span class="cov4" title="6">{
        if cb.tokens == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="6">select </span>{
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        case &lt;-cb.tokens:<span class="cov4" title="5">
                return nil</span>
        }
}

// isRetryable checks if an error is considered transient/retryable,
// such as timeouts, connection resets, or temporary network failures.
func isRetryable(err error) bool <span class="cov2" title="2">{
        var netErr net.Error
        if errors.As(err, &amp;netErr) </span><span class="cov2" title="2">{
                return netErr.Temporary() || netErr.Timeout()
        }</span>

        <span class="cov0" title="0">var opErr *net.OpError
        if errors.As(err, &amp;opErr) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if errors.Is(err, syscall.ECONNRESET) || errors.Is(err, syscall.ECONNREFUSED) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if errors.Is(err, os.ErrDeadlineExceeded) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package circuitbreaker

import "sync"

// Manager is responsible for managing multiple CircuitBreaker instances.
// It acts as a centralized registry, ensuring that each named CircuitBreaker
// is only instantiated once and reused for all future requests.
//
// This design enables:
// - Centralized lifecycle management
// - Thread-safe access to named CircuitBreakers
// - Avoidance of redundant instantiations
type Manager struct {
        mu sync.RWMutex
        cb map[string]*CircuitBreaker
}

// NewManager initializes and returns a new Manager instance.
// It prepares an empty map and a mutex for thread-safe management.
func NewManager() *Manager <span class="cov1" title="1">{
        return &amp;Manager{
                cb: make(map[string]*CircuitBreaker),
        }
}</span>

// NewCircuitBreaker creates and stores a new CircuitBreaker if one
// with the given name doesn't already exist.
//
// Parameters:
// - name: unique name for the circuit
// - maxConcurrent: maximum concurrent HTTP requests allowed
// - maxRequests: max number of requests in the rate-limit window
// - windowSeconds: duration of the rate-limit window
// - maxRetries: number of retry attempts for failed requests
//
// Returns:
// - A pointer to the existing or newly created CircuitBreaker instance
func (m *Manager) NewCircuitBreaker(
        name string,
        maxConcurrent, maxRequests int,
        windowSeconds int,
        maxRetries int,
) *CircuitBreaker <span class="cov1" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if cb, ok := m.cb[name]; ok </span><span class="cov0" title="0">{
                return cb
        }</span>

        <span class="cov1" title="1">cb := NewCircuitBreaker(name, maxConcurrent, maxRequests, windowSeconds, maxRetries)
        m.cb[name] = cb
        return cb</span>
}

// GetCircuitBreaker retrieves a CircuitBreaker by name from the manager.
//
// Returns:
// - The CircuitBreaker pointer if it exists
// - nil if no CircuitBreaker with the given name was found
func (m *Manager) GetCircuitBreaker(name string) *CircuitBreaker <span class="cov10" title="2">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if cb, ok := m.cb[name]; ok </span><span class="cov1" title="1">{
                return cb
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
